import { defineComponent as A, createVNode as i, Fragment as D, toRefs as P, withDirectives as S, mergeProps as y, unref as l, resolveDirective as B, isVNode as E } from "vue";
import { ElDescriptions as O, ElDescriptionsItem as F } from "element-plus";
const L = { data: { type: Array, default: [] }, columns: { type: Array, default: [] }, loading: { type: Object, default: () => ({ load: !1, text: "Loading...", svg: "", spinner: "", svgViewBox: "", background: "" }) }, align: { type: String, default: "left" }, labelAlign: { type: String, default: "" }, ...O.props }, j = A({ name: "Renderer", props: { render: { type: Function }, params: { type: Object } }, setup: (a) => () => i(D, null, [a.render(a.params)]) }), m = A({ name: "PureDescriptions", props: L, setup(a, { slots: t, attrs: r }) {
  const { data: R, columns: h, align: k, labelAlign: w, loading: s } = P(a), c = { title: () => (t == null ? void 0 : t.title) && t.title({ props: a, attrs: r }) }, b = { extra: () => (t == null ? void 0 : t.extra) && t.extra({ props: a, attrs: r }) }, V = (t == null ? void 0 : t.title) && !(t != null && t.extra) ? c : (t == null ? void 0 : t.extra) && !(t != null && t.title) ? b : (t == null ? void 0 : t.title) && (t == null ? void 0 : t.extra) ? Object.assign(c, b) : null;
  return () => {
    var f;
    return S(i(O, y(a, r, { "element-loading-text": (f = l(s).text) != null ? f : "Loading...", "element-loading-svg": l(s).svg, "element-loading-spinner": l(s).spinner, "element-loading-svg-view-box": l(s).svgViewBox, "element-loading-background": l(s).background }), { default: () => [l(h).map((e, o) => {
      let p = l(R).map((d) => d[e == null ? void 0 : e.prop]);
      const v = { default: () => {
        var d;
        return e != null && e.cellRenderer ? i(j, { render: e.cellRenderer, params: { props: a, attrs: r, index: o, value: p[0] } }, null) : e != null && e.slot ? (d = t == null ? void 0 : t[e.slot]) == null ? void 0 : d.call(t, { props: a, attrs: r, index: o, value: p[0] }) : i(D, null, e != null && e.value ? [l(e.value)] : [p]);
      } }, n = e != null && e.labelRenderer ? { label: () => i(j, { render: e.labelRenderer, params: { props: a, attrs: r, index: o, value: p[0] } }, null), ...v } : v;
      return x = e == null ? void 0 : e.hide, typeof x == "function" && (e == null ? void 0 : e.hide(r)) ? e == null ? void 0 : e.hide(r) : i(F, y(e, { key: o, align: e.align ? e.align : l(k), labelAlign: e.labelAlign ? e.labelAlign : l(w) }), typeof (g = n) == "function" || Object.prototype.toString.call(g) === "[object Object]" && !E(g) ? n : { default: () => [n] });
      var x, g;
    })], ...V }), [[B("loading"), l(s).load]]);
  };
} }), I = Object.assign(m, { install: function(a) {
  a.component(m.name, m);
} });
export {
  I as PureDescriptions,
  I as default
};
